import{options as e,Fragment as n,Component as t}from"../preact.js";"undefined"!=typeof window&&window.__PREACT_DEVTOOLS__&&window.__PREACT_DEVTOOLS__.attachPreact("10.4.4",e,{Fragment:n,Component:t});var o={};function r(){o={}}function a(e){return e.type===n?"Fragment":"function"==typeof e.type?e.type.displayName||e.type.name:"string"==typeof e.type?e.type:"#text"}var i=[],s=[];function p(){return i.length>0?i[i.length-1]:null}var c=!1;function l(e){return"function"==typeof e.type&&e.type!=n}function u(e){for(var n=[e],t=e;null!=t.__o;)n.push(t.__o),t=t.__o;return n.reduce((function(e,n){e+="  in "+a(n);var t=n.__source;return t?e+=" (at "+t.fileName+":"+t.lineNumber+")":c||(c=!0,console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")),e+"\n"}),"")}var f="function"==typeof WeakMap,d=t.prototype.setState;t.prototype.setState=function(e,n){return null==this.__v?null==this.state&&console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n'+u(p())):null==this.__P&&console.warn('Can\'t call "this.setState" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n'+u(this.__v)),d.call(this,e,n)};var _=t.prototype.forceUpdate;function y(e){var n=e.props,t=a(e),o="";for(var r in n)if(n.hasOwnProperty(r)&&"children"!==r){var i=n[r];"function"==typeof i&&(i="function "+(i.displayName||i.name)+"() {}"),i=Object(i)!==i||i.toString?i+"":Object.prototype.toString.call(i),o+=" "+r+"="+JSON.stringify(i)}var s=n.children;return"<"+t+o+(s&&s.length?">..</"+t+">":" />")}t.prototype.forceUpdate=function(e){return null==this.__v?console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n'+u(p())):null==this.__P&&console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n'+u(this.__v)),_.call(this,e)},function(){!function(){var n=e.__b,t=e.diffed,o=e.__,r=e.vnode,a=e.__r;e.diffed=function(e){l(e)&&s.pop(),i.pop(),t&&t(e)},e.__b=function(e){l(e)&&i.push(e),n&&n(e)},e.__=function(e,n){s=[],o&&o(e,n)},e.vnode=function(e){e.__o=s.length>0?s[s.length-1]:null,r&&r(e)},e.__r=function(e){l(e)&&s.push(e),a&&a(e)}}();var n=e.__b,t=e.diffed,r=e.vnode,p=e.__e,c=e.__,d=e.__h,_=f?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null;e.__e=function(e,n,t){if(n&&n.__c&&"function"==typeof e.then){var o=e;e=new Error("Missing Suspense. The throwing component was: "+a(n));for(var r=n;r;r=r.__)if(r.__c&&r.__c.__c){e=o;break}if(e instanceof Error)throw e}p(e,n,t)},e.__=function(e,n){if(!n)throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");var t;switch(n.nodeType){case 1:case 11:case 9:t=!0;break;default:t=!1}if(!t){var o=a(e);throw new Error("Expected a valid HTML node as a second argument to render.\tReceived "+n+" instead: render(<"+o+" />, "+n+");")}c&&c(e,n)},e.__b=function(e){var t,r,i,s=e.type,p=function e(n){return n?"function"==typeof n.type?e(n.__):n:{}}(e.__);if(void 0===s)throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports"+y(e)+"\n\n"+u(e));if(null!=s&&"object"==typeof s){if(void 0!==s.__k&&void 0!==s.__e)throw new Error("Invalid type passed to createElement(): "+s+"\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My"+a(e)+" = "+y(s)+";\n  let vnode = <My"+a(e)+" />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n"+u(e));throw new Error("Invalid type passed to createElement(): "+(Array.isArray(s)?"array":s))}if("thead"!==s&&"tfoot"!==s&&"tbody"!==s||"table"===p.type?"tr"===s&&"thead"!==p.type&&"tfoot"!==p.type&&"tbody"!==p.type&&"table"!==p.type?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent."+y(e)+"\n\n"+u(e)):"td"===s&&"tr"!==p.type?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+y(e)+"\n\n"+u(e)):"th"===s&&"tr"!==p.type&&console.error("Improper nesting of table. Your <th> should have a <tr>."+y(e)+"\n\n"+u(e)):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+y(e)+"\n\n"+u(e)),void 0!==e.ref&&"function"!=typeof e.ref&&"object"!=typeof e.ref&&!("$$typeof"in e))throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got ['+typeof e.ref+"] instead\n"+y(e)+"\n\n"+u(e));if("string"==typeof e.type)for(var c in e.props)if("o"===c[0]&&"n"===c[1]&&"function"!=typeof e.props[c]&&null!=e.props[c])throw new Error("Component's \""+c+'" property should be a function, but got ['+typeof e.props[c]+"] instead\n"+y(e)+"\n\n"+u(e));if("function"==typeof e.type&&e.type.propTypes){if("Lazy"===e.type.displayName&&_&&!_.lazyPropTypes.has(e.type)){var l="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{var f=e.type();_.lazyPropTypes.set(e.type,!0),console.warn(l+"Component wrapped in lazy() is "+a(f))}catch(e){console.warn(l+"We will log the wrapped component's name once it is loaded.")}}t=e.type.propTypes,r=e.props,i=a(e),Object.keys(t).forEach((function(e){var n;try{n=t[e](r,e,i,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(e){n=e}!n||n.message in o||(o[n.message]=!0,console.error("Failed prop type: "+n.message))}))}n&&n(e)},e.__h=function(e,n,t){if(!e)throw new Error("Hook can only be invoked from render methods.");d&&d(e,n,t)};var h=function(e,n){return{get:function(){console.warn("getting vnode."+e+" is deprecated, "+n)},set:function(){console.warn("setting vnode."+e+" is not allowed, "+n)}}},m={nodeName:h("nodeName","use vnode.type"),attributes:h("attributes","use vnode.props"),children:h("children","use vnode.props.children")},v=Object.create({},m);e.vnode=function(e){var n=e.props;if(null!==e.type&&null!=n&&("__source"in n||"__self"in n)){var t=e.props={};for(var o in n){var a=n[o];"__source"===o?e.__source=a:"__self"===o?e.__self=a:t[o]=a}}e.__proto__=v,r&&r(e)},e.diffed=function(e){e.__k&&e.__k.forEach((function(n){if(n&&void 0===n.type){delete n.__,delete n.__b;var t=Object.keys(n).join(",");throw new Error("Objects are not valid as a child. Encountered an object with the keys {"+t+"}.\n\n"+u(e))}}));var n=e.__c;if(n&&n.__H){var o=n.__H;Array.isArray(o.__)&&o.__.forEach((function(n){if(n.__h&&(!n.__H||!Array.isArray(n.__H))){var t=a(e);console.warn("In "+t+" you are calling useMemo/useCallback without passing arguments.\nThis is a noop since it will not be able to memoize, it will execute it every render.\n\n"+u(e))}}))}if(t&&t(e),null!=e.__k)for(var r=[],i=0;i<e.__k.length;i++){var s=e.__k[i];if(s&&null!=s.key){var p=s.key;if(-1!==r.indexOf(p)){console.error('Following component has two or more children with the same key attribute: "'+p+'". This may cause glitches and misbehavior in rendering process. Component: \n\n'+y(e)+"\n\n"+u(e));break}r.push(p)}}}}();export{r as resetPropWarnings};
